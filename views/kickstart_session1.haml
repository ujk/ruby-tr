-# coding: UTF-8

%script
  document.title = "Ruby Türkiye - Kickstart - Seri-1"

%div.row
  %div.leaderboard
    %h1 Ruby Ögretiler Seri - 1 
    %h4 
      Orjinali : 
      %a(href="https://github.com/JoshCheek/ruby-kickstart/tree/master/session1" target="_blank") Ruby-Kickstart
    %h4 Çeviren : Ümit Kayacık

%br

%div.row
  %div.span12
    %h4.sag 01-intro.rb
    
    :coderay
      #!Ruby
      # Ruby Dilinin Kaynağı:
      #   Yazan: Matz (Yukihiro Matsumoto)
      #   İlk Yayınlanması: 1995
      #   Ruby dinamik (derle), strong typing (çoğunlukla), dynamic typing (duck typing diye bilinir)
      #   (Ördek gibi yürüyen, ördek gibi yüzen ve ördek gibi öten bir kuş gördüysem , o bir ördektir)
      #   Temelleri:
      #     Prosedural
      #     OO (object oriented - nesne temelli - bazı operatörler hariç, _herşey_ bir objedir)
      #     Fonksiyonel

      # Neden Ruby?
      #   Çok taze! Okulumuzun mail listelerinden bir istatistik:
      #     2010'dan beri olan iş imkanları % değişimi
      #     Ruby on Rails        +84%
      #     Python               +53%
      #     MySQL                +46%
      #     PHP                  +43%
      #     Ajax                 +37%
      #     Linux                +31%
      #     Perl                 +25%
      #     Apache               +24%
      #     Tomcat               +24%
      #     Red Hat Linux        +21%
      #     
      #     Kaynak: Dice.com via May 9, 2011 ComputerWorld
      # 
      #   Tamam, ama Ruby ne alemde Rails değil? derseniz
      #     $ rvm list known
      #     
      #     MacRuby'yi gördünüz mü? Size söylüyorum Apple Objective C'den MacRuby'ye geçiyor.
      #     Bu Mac için yazılım geliştirecekseniz Ruby kullanacaksınız demek, bu iPhone 
      #     yazılımı geliştirmek için Ruby kullanacaksınız demek. iPhone çıktığında Objective C ne 
      #     olmuştu hatırlayın. Bu güç şimdi Ruby'ye kayıyor
      #     
      #     JRuby'yi gördünüz mü? JVM harika bir şey ve Ruby'nin gücüne sahipsiniz.  
      #     Harika Java kütüphaneleri var. Bununla Ruby'nin gücü bir arada. 
      #     JVM sayesinde her yerde çalışabilir.
      # 
      #   Rubyistler neşelidir. Program yazmayı severiz. Zerafeti severiz.
      #   Diğerlerinin yazılıma bakışını değiştiririz. Ruby on Rails 
      #   sahne de çok çabuk yer aldı çünkü çok hızlı geliştirme yapılabilir. 
      #   Web domainde "spagetti kod" karşısında güzel ve şıktır ve herşeyi "doğru"
      #   yapma ilkesiyle sınırları zorlar.
      # 
      # Düşünün, kendi sorunlarınız hakim olabilir ve onları çözebilirsiniz.
      # Parlak bir mimar gibi hayalinizdeki her şeyi yapabilirsiniz.
      # "Whoever holds the keys to programming ends up building the reality in which the rest of us live."
      # -- Douglas Rushkoff    
    %br
    
    %br
    %h4.sag 02-conventions.rb
    :coderay
      #!Ruby
      # Notlarda , örneklerde ve verilen kartlarda birkaç basit yöntemle kodlarımızı yazdık
      # işlemlerin sonuçlarını göstermek için aşağıdaki notasyonu kullandık.

      3 + 9       # => 12
      my_var = 4
      my_var      # => 4

      # Burada yorum olarak işlemin sonucu yer alır eğer sadece bir değişken varsa onun değerini verir

      # Daha karmaşık sonuçlarda mesela print işlem sonucunda bir alt satıra sonuç yazılacaktır

    %br
    
    %br
    %h4.sag 03-object-definition.rb
    :coderay
      #!Ruby
        # Ruby işlediği veriyi ve onu işleme yollarını nesne (object) adı verilen sanal yerlerde organize eder
        # Örneğin, veri bir sayı olsun ve bu sayıya uygulanabilen işlemler. Bu sayı nesnesi şöyle tanımlanır.

        # 5 sayısı için veri 1'ler ve 0'lardan oluşur ve şuna benzer
        "%032b" % 5 # => "00000000000000000000000000000101"

        # ve bı 5 sayısı bir nesne olduğu için kendisinin metodları (işlemleri) da vardır
        5.even? # => false
        5.odd?  # => true
        5.next  # => 6
    %br
    
    %br
    %h4.sag 04-variables.rb
    :coderay
      #!Ruby
      # Bir nesnenin bilgileri hafızanın "yığın" adı verilen bir parçasında bulunur
      # Ruby bir nesneyi saklamak istediğinde , yığına gider , kullanılabilir ilk hafıza yerini bulur ve nesne bilgilerini buraya saklar.
      # Fakat nesnemizi nereye koyduğumuzu nasıl bileceğiz? Yerini bilebilmek için ve daha sonra kullanabilmek için birşeylere
      # ihtiyaç duyarız (adres bilgisi).
      #
      # Değişkenler hafızadaki adresleri gösteren işaret parmakları gibidirler!
      # Onlar bize nesnelerimizin nerede olduğunu gösterirler -- bu sayede nesnelere değişkenler yoluyla erişebilirsiniz.
      
      five = 5 # "five" bir değişkendir, 5 ise onun gösterdiği nesnedir
                      
      five.even? # => false (çift mi?)
      five.odd? # => true (tek mi?)
      five.next # => 6 (sonraki sayı)
      
      
      # değişkenler yeni değerleri (nesneleri) gösterecek şekilde ayarlanabilir
      
      five # => 5
      five = "five"
      five # => "five"
    %br
    
    %br
    %h4.sag 05-methods.rb
    :coderay
      #!Ruby
      # Nesneleri bir dizi komutlar yardımıyla değiştirmek için metodlar kullanılır.
      # Örneğin , bir yazının kelimelerinin ilk harflerini büyük yapmak için "capitalize" adı verilen metod kullanılır.
      
      "josh".capitalize # => "Josh"
      
      
      
      # Siz kendiniz de metodlar tanımlayabilirsiniz!
      
      def bu_bir_metod_mu?
        "Evet oyle!" # "Evet oyle!" bir nesnedir. Bu metod tanımı içindeki son nesne olduğundan sonuç olarak o geri dönecektir.
      end

      bu_bir_metod_mu? # => "Evet oyle!"
    %br
    
    %br
    %h4.sag 06-method-scope.rb
    :coderay
      #!Ruby
      # Bir metod yaptığınızda , şunu unutmayın o kendi küçük dünyasındadır,
      # bu dünyanın dışındaki şeylerden haberi olmayacaktır , buna scope denir.
      
      defined? oniki # => nil
      oniki = 12
      defined? oniki # => "local-variable" (yerel değişken)

      def benim_kucuk_dunyam
        defined? oniki # => nil
      end

      benim_kucuk_dunyam # => nil
      defined? oniki # => "local-variable"
      
      
      
      # Pekala pek de kullanışsız görünüyor di mi? Allahtan bu dünyada bir internet bağlantısı var!
      # Nesneleri metod tanımlaması içine gönderebiliriz. Bu içeri taşıma işini yapan değişkenlere ise
      # argüman ya da parametre denir

      # person1 ve person2 argüman ya da parametredir
      def ısınla_beni(person1, person2)
        "Dışardaki ekip \#{person1} ve \#{person2}'den oluşuyor."
      end
      
      ısınla_beni("Ryker", "Data") # => "Dışardaki ekip Ryker ve Data'den oluşuyor."
    %br
    
    %br
    %h4.sag 07-method-arguments.rb
    :coderay
      #!Ruby
      # Bildiğiniz gibi siz ve ben aynı web sitesine gidebiliriz, fakat ikimiz de tarayıcımızda aynı anda web sitesini
      # gördüğümüz halde , aslında sadece bir tane web sitesi vardır?
      #
      # Nesneler de aynıdır , biz birini metoda gönderdiğimizde ona hem metodun içinden hem de
      # dışında erişebiliriz. Ancak hala bir tane nesne vardır.

      def browser_goto(website)
        website.object_id # => 2151945040, 2151945040
        "Tarayıcınız \#{website} sitesine yönlendiriliyor"
      end

      # aynı object id aynı nesne demektir
      website = "ruby-kickstart.com"
      website.object_id # => 2151945040
      browser_goto(website) # => "Tarayıcınız ruby-kickstart.com sitesine yönlendiriliyor"

      # Ruby havalı bir dil olmayı sever, ne dediğnizi anlamak için parantezler içinde vermenize gerek yoktur.
      browser_goto website # => "Tarayıcınız ruby-kickstart.com sitesine yönlendiriliyor"
    %br
    
    %br
    %h4.sag 08-operators.rb
    :coderay
      #!Ruby
      # Operatör adı verilen bazı özel metodlar vardır.
      # Özeldirler çünkü Ruby yorumlayıcısı onları daha serbest kullanmanıza izin verir, sadece metod olmalarına rağmen.
      # Buna syntactic sugar (sözdizimsel şeker) denilir!

      # + adında bir metod vardır
      3.+(5) # => 8

      # fakat bu çirkin bir görüntü , Ruby bunu daha havalı şekilde şöyle yazmanıza imkan verir
      3 + 5 # => 8
      2 - 4 # => -2
      10 / 3 # => 3
      10 % 3 # => 1
      
      # Gördünüz mü, ne istediğinizi biliyor :)
      # (% işlemi size bölümden kalanı verir)
      
      # Ruby size yardımcı olmaya çalışır , fakat syntactic sugar çok yardımcı olmayabilir
      # eğer bir sıralama yapacaksa Ruby işlemlerin yapılma sırasına bağlı kalacaktır.
      2 * 3 + 10 # => 16
      2 + 3 * 10 # => 32
      
      # soru: eğer operatörler sadece nesneler üzerindeki metodlarsa, sayılardan başka nesneler de
      # operatörlere sahip midir? Hemen bir irb açın ve deneyin!
    %br
    
    %br
    %h4.sag 09-numbers.rb
    :coderay
      #!Ruby
      # Gerçekçi dünyanın kısıtlamalarından dolayı , matematik dersanelerde yapıldığı şekliyle yapılamaz
      # Bu şu demektir , siz 10 ve 10.0 sayılarının eşit olduğunu düşünseniz bile bu birçok programlama 
      # dili için böyle değildir.
      
      10.class.ancestors # => [Fixnum, Integer, Numeric, Comparable, Object, Kernel, BasicObject]
      10.0.class.ancestors # => [Float, Numeric, Comparable, Object, Kernel, BasicObject]
      
      # Her ikisi de sayıdır (henüz sınıflardan bahsetmedik, fakat atalarından Numeric gördüğünüz gibi ortak)
      # fakat biraz farklı davranırlar. Örneğin tamsayıların (integer) bölünmesi tamsayı bir sonuç verir, 
      # fakat noktalı sayı (float) bölünmesi noktalı sayı verir
      10 / 3 # => 3
      10.0 / 3 # => 3.3333333333333335
      
      # eğer birbirlerine dönüştürmek istersek?
      10.to_f # => 10.0
      10.0.to_i # => 10
      
      # Ayrıca parantezler de kullanabilirsiniz. Parantezler içindeki işlemin sonuç değerini alır.
      (1 + 2) * 3 # => 9
      (91 + 2).even? # => false
    %br
    
    %br
    %h4.sag 10-introducing-strings.rb
    :coderay
      #!Ruby
      # Geleneklerden dolayı programlama dillerinde yazılara "string" (dizi) denir
      # tırnaklar arasındaki karakterlerin dizilmesi olarak düşünebilirsiniz. 
      # soru: eğer 10.to_f 10 sayısını float yapıyorsa, 10 sayısını nasıl string yaparsınız?

      "text".class # => String

      # Bir stringi tırnaklar içinde ifade ederek belirtebilirsiniz

      "abc" # => "abc"
      'abc' # => "abc"
    %br
    
    %br
    %h4.sag 11-stdin-and-stdout.rb
    :coderay
      #!Ruby
      # Klasik programlar bir terminalde çalışır yazı girişlerini okur ve çıktı olarak yazı geri verirler.
      # Bu birçok farklı programın birbiriyle etkileşimde bulunduğu ortak bir arabirimdir.

      # Bir program yazı çıktısı verdiğinde biz onu standart çıkışa (stdout) gönderdiğini kabul ederiz.
      # Terminalde stdout'a gönderilen her çıktı terminalde gösterilir.
      # Örneğin cat komutu dosya içeriğini standart çıkışa gönderir, echo argümanlarını standart çıkışa gönderir.

      # Progam ne zaman bir yazı okursa onu standart girişten alır (stdin).
      # Terminalde stdin tuş takımınızdan gelen bilgileri alır.
      # Klavyeden ne girerseniz programınızın stdin'ine gönderilir.

      # stdin'den bir giriş okumak için gets komutu kullanılır
      user_response = gets

      # stdout'a yazmak için puts komutu kullanılır
      puts "Dediniz ki: \#{user_response}"



      # Dikkat
      #
      # Bir satır enter tuşuyla biten bir yazıdır. line = "Line\n"
      # Satırı okuduğunuzda ayrıca enter tuşunu da okursunuz.
      # Bunun anlamı: line + line # => "Line\nLine\n"
      #
      # Eğer _gerçekte_ "LineLine" istiyorsanız:
      # enter tuş karakterini uzaklaştırmanız gerekir.
      #
      # Ruby size chomp adı verilen ve dizin,n sonundan enter tuş karakterini çıkaran bir metod verir
      # line.chomp # => "Line"
      # line # => "Line\n"
      #
    %br
    
    %br
    %h4.sag 12-puts.rb
    :coderay
      #!Ruby
      # Ruby yazıları stdout'a göndermek için birçok metoda sahiptir, en çok kullanılanı puts'dir:
      puts "Welcome to the program!"
      
        # Çıktı:
        # Welcome to the program!
        #


      # Dikkat ederseniz puts yazdığı yazınını arkasına yeni satıra geçiş ekler ve puts yazacağı nesneyi önce 
      # string'e çevirir , sonra yazar:
      puts 45
      
        # Çıktı:
        # 45
        #
      
      
      # puts diğer nesneleri String'e çevirirken onların to_s metodunu kullanır.
      # ve sonra string değeri yazar. Şöyle çalışır.
      number = 56
      thing_to_print = number.to_s
      puts thing_to_print

        # çıktı:
        # 56
        #
    %br
    
    %br
    
    
%hr

#disqus_thread
%script(type="text/javascript" async="true" src="http://ruby-tr.disqus.com/embed.js")
  
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
