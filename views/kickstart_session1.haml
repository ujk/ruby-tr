-# coding: UTF-8

%script
  document.title = "Ruby Türkiye - Kickstart - Seri-1"

%div.row
  %div.leaderboard
    %h1 Ruby Ögretiler Seri - 1 
    %h4 
      Orjinali : 
      %a(href="https://github.com/JoshCheek/ruby-kickstart/tree/master/session1" target="_blank") Ruby-Kickstart
    %h4 Çeviren : Ümit Kayacık

%br

%div.row
  %div.span12
    %h4.sag 01-intro.rb
    
    :coderay
      #!Ruby
      # Ruby Dilinin Kaynağı:
      #   Yazan: Matz (Yukihiro Matsumoto)
      #   İlk Yayınlanması: 1995
      #   Ruby dinamik (derle), strong typing (çoğunlukla), dynamic typing (duck typing diye bilinir)
      #   (Ördek gibi yürüyen, ördek gibi yüzen ve ördek gibi öten bir kuş gördüysem , o bir ördektir)
      #   Temelleri:
      #     Prosedural
      #     OO (object oriented - nesne temelli - bazı operatörler hariç, _herşey_ bir objedir)
      #     Fonksiyonel

      # Neden Ruby?
      #   Çok taze! Okulumuzun mail listelerinden bir istatistik:
      #     2010'dan beri olan iş imkanları % değişimi
      #     Ruby on Rails        +84%
      #     Python               +53%
      #     MySQL                +46%
      #     PHP                  +43%
      #     Ajax                 +37%
      #     Linux                +31%
      #     Perl                 +25%
      #     Apache               +24%
      #     Tomcat               +24%
      #     Red Hat Linux        +21%
      #     
      #     Kaynak: Dice.com via May 9, 2011 ComputerWorld
      # 
      #   Tamam, ama Ruby ne alemde Rails değil? derseniz
      #     $ rvm list known
      #     
      #     MacRuby'yi gördünüz mü? Size söylüyorum Apple Objective C'den MacRuby'ye geçiyor.
      #     Bu Mac için yazılım geliştirecekseniz Ruby kullanacaksınız demek, bu iPhone 
      #     yazılımı geliştirmek için Ruby kullanacaksınız demek. iPhone çıktığında Objective C ne 
      #     olmuştu hatırlayın. Bu güç şimdi Ruby'ye kayıyor
      #     
      #     JRuby'yi gördünüz mü? JVM harika bir şey ve Ruby'nin gücüne sahipsiniz.  
      #     Harika Java kütüphaneleri var. Bununla Ruby'nin gücü bir arada. 
      #     JVM sayesinde her yerde çalışabilir.
      # 
      #   Rubyistler neşelidir. Program yazmayı severiz. Zerafeti severiz.
      #   Diğerlerinin yazılıma bakışını değiştiririz. Ruby on Rails 
      #   sahne de çok çabuk yer aldı çünkü çok hızlı geliştirme yapılabilir. 
      #   Web domainde "spagetti kod" karşısında güzel ve şıktır ve herşeyi "doğru"
      #   yapma ilkesiyle sınırları zorlar.
      # 
      # Düşünün, kendi sorunlarınız hakim olabilir ve onları çözebilirsiniz.
      # Parlak bir mimar gibi hayalinizdeki her şeyi yapabilirsiniz.
      # "Whoever holds the keys to programming ends up building the reality in which the rest of us live."
      # -- Douglas Rushkoff    
    %br
    
    %br
    %h4.sag 02-conventions.rb
    :coderay
      #!Ruby
      # Notlarda , örneklerde ve verilen kartlarda birkaç basit yöntemle kodlarımızı yazdık
      # işlemlerin sonuçlarını göstermek için aşağıdaki notasyonu kullandık.

      3 + 9       # => 12
      my_var = 4
      my_var      # => 4

      # Burada yorum olarak işlemin sonucu yer alır eğer sadece bir değişken varsa onun değerini verir

      # Daha karmaşık sonuçlarda mesela print işlem sonucunda bir alt satıra sonuç yazılacaktır

    %br
    
    %br
    %h4.sag 03-object-definition.rb
    :coderay
      #!Ruby
        # Ruby işlediği veriyi ve onu işleme yollarını nesne (object) adı verilen sanal yerlerde organize eder
        # Örneğin, veri bir sayı olsun ve bu sayıya uygulanabilen işlemler. Bu sayı nesnesi şöyle tanımlanır.

        # 5 sayısı için veri 1'ler ve 0'lardan oluşur ve şuna benzer
        "%032b" % 5 # => "00000000000000000000000000000101"

        # ve bı 5 sayısı bir nesne olduğu için kendisinin metodları (işlemleri) da vardır
        5.even? # => false
        5.odd?  # => true
        5.next  # => 6
    %br
    
    %br
    %h4.sag 04-variables.rb
    :coderay
      #!Ruby
      # Bir nesnenin bilgileri hafızanın "yığın" adı verilen bir parçasında bulunur
      # Ruby bir nesneyi saklamak istediğinde , yığına gider , kullanılabilir ilk hafıza yerini bulur ve nesne bilgilerini buraya saklar.
      # Fakat nesnemizi nereye koyduğumuzu nasıl bileceğiz? Yerini bilebilmek için ve daha sonra kullanabilmek için birşeylere
      # ihtiyaç duyarız (adres bilgisi).
      #
      # Değişkenler hafızadaki adresleri gösteren işaret parmakları gibidirler!
      # Onlar bize nesnelerimizin nerede olduğunu gösterirler -- bu sayede nesnelere değişkenler yoluyla erişebilirsiniz.
      
      five = 5 # "five" bir değişkendir, 5 ise onun gösterdiği nesnedir
                      
      five.even? # => false (çift mi?)
      five.odd? # => true (tek mi?)
      five.next # => 6 (sonraki sayı)
      
      
      # değişkenler yeni değerleri (nesneleri) gösterecek şekilde ayarlanabilir
      
      five # => 5
      five = "five"
      five # => "five"
    %br
    
    %br
    %h4.sag 05-methods.rb
    :coderay
      #!Ruby
      # Nesneleri bir dizi komutlar yardımıyla değiştirmek için metodlar kullanılır.
      # Örneğin , bir yazının kelimelerinin ilk harflerini büyük yapmak için "capitalize" adı verilen metod kullanılır.
      
      "josh".capitalize # => "Josh"
      
      
      
      # Siz kendiniz de metodlar tanımlayabilirsiniz!
      
      def bu_bir_metod_mu?
        "Evet oyle!" # "Evet oyle!" bir nesnedir. Bu metod tanımı içindeki son nesne olduğundan sonuç olarak o geri dönecektir.
      end

      bu_bir_metod_mu? # => "Evet oyle!"
    %br
    
    %br
    %h4.sag 06-method-scope.rb
    :coderay
      #!Ruby
      # Bir metod yaptığınızda , şunu unutmayın o kendi küçük dünyasındadır,
      # bu dünyanın dışındaki şeylerden haberi olmayacaktır , buna scope denir.
      
      defined? oniki # => nil
      oniki = 12
      defined? oniki # => "local-variable" (yerel değişken)

      def benim_kucuk_dunyam
        defined? oniki # => nil
      end

      benim_kucuk_dunyam # => nil
      defined? oniki # => "local-variable"
      
      
      
      # Pekala pek de kullanışsız görünüyor di mi? Allahtan bu dünyada bir internet bağlantısı var!
      # Nesneleri metod tanımlaması içine gönderebiliriz. Bu içeri taşıma işini yapan değişkenlere ise
      # argüman ya da parametre denir

      # person1 ve person2 argüman ya da parametredir
      def ısınla_beni(person1, person2)
        "Dışardaki ekip \#{person1} ve \#{person2}'den oluşuyor."
      end
      
      ısınla_beni("Ryker", "Data") # => "Dışardaki ekip Ryker ve Data'den oluşuyor."
    %br
    
    %br
    %h4.sag 07-method-arguments.rb
    :coderay
      #!Ruby
      # Bildiğiniz gibi siz ve ben aynı web sitesine gidebiliriz, fakat ikimiz de tarayıcımızda aynı anda web sitesini
      # gördüğümüz halde , aslında sadece bir tane web sitesi vardır?
      #
      # Nesneler de aynıdır , biz birini metoda gönderdiğimizde ona hem metodun içinden hem de
      # dışında erişebiliriz. Ancak hala bir tane nesne vardır.

      def browser_goto(website)
        website.object_id # => 2151945040, 2151945040
        "Tarayıcınız \#{website} sitesine yönlendiriliyor"
      end

      # aynı object id aynı nesne demektir
      website = "ruby-kickstart.com"
      website.object_id # => 2151945040
      browser_goto(website) # => "Tarayıcınız ruby-kickstart.com sitesine yönlendiriliyor"

      # Ruby havalı bir dil olmayı sever, ne dediğnizi anlamak için parantezler içinde vermenize gerek yoktur.
      browser_goto website # => "Tarayıcınız ruby-kickstart.com sitesine yönlendiriliyor"
    %br
    
    %br
    %h4.sag 08-operators.rb
    :coderay
      #!Ruby
      # Operatör adı verilen bazı özel metodlar vardır.
      # Özeldirler çünkü Ruby yorumlayıcısı onları daha serbest kullanmanıza izin verir, sadece metod olmalarına rağmen.
      # Buna syntactic sugar (sözdizimsel şeker) denilir!

      # + adında bir metod vardır
      3.+(5) # => 8

      # fakat bu çirkin bir görüntü , Ruby bunu daha havalı şekilde şöyle yazmanıza imkan verir
      3 + 5 # => 8
      2 - 4 # => -2
      10 / 3 # => 3
      10 % 3 # => 1
      
      # Gördünüz mü, ne istediğinizi biliyor :)
      # (% işlemi size bölümden kalanı verir)
      
      # Ruby size yardımcı olmaya çalışır , fakat syntactic sugar çok yardımcı olmayabilir
      # eğer bir sıralama yapacaksa Ruby işlemlerin yapılma sırasına bağlı kalacaktır.
      2 * 3 + 10 # => 16
      2 + 3 * 10 # => 32
      
      # soru: eğer operatörler sadece nesneler üzerindeki metodlarsa, sayılardan başka nesneler de
      # operatörlere sahip midir? Hemen bir irb açın ve deneyin!
    %br
    
    %br
    %h4.sag 09-numbers.rb
    :coderay
      #!Ruby
      # Gerçekçi dünyanın kısıtlamalarından dolayı , matematik dersanelerde yapıldığı şekliyle yapılamaz
      # Bu şu demektir , siz 10 ve 10.0 sayılarının eşit olduğunu düşünseniz bile bu birçok programlama 
      # dili için böyle değildir.
      
      10.class.ancestors # => [Fixnum, Integer, Numeric, Comparable, Object, Kernel, BasicObject]
      10.0.class.ancestors # => [Float, Numeric, Comparable, Object, Kernel, BasicObject]
      
      # Her ikisi de sayıdır (henüz sınıflardan bahsetmedik, fakat atalarından Numeric gördüğünüz gibi ortak)
      # fakat biraz farklı davranırlar. Örneğin tamsayıların (integer) bölünmesi tamsayı bir sonuç verir, 
      # fakat noktalı sayı (float) bölünmesi noktalı sayı verir
      10 / 3 # => 3
      10.0 / 3 # => 3.3333333333333335
      
      # eğer birbirlerine dönüştürmek istersek?
      10.to_f # => 10.0
      10.0.to_i # => 10
      
      # Ayrıca parantezler de kullanabilirsiniz. Parantezler içindeki işlemin sonuç değerini alır.
      (1 + 2) * 3 # => 9
      (91 + 2).even? # => false
    %br
    
    %br
    %h4.sag 10-introducing-strings.rb
    :coderay
      #!Ruby
      # Geleneklerden dolayı programlama dillerinde yazılara "string" (dizi) denir
      # tırnaklar arasındaki karakterlerin dizilmesi olarak düşünebilirsiniz. 
      # soru: eğer 10.to_f 10 sayısını float yapıyorsa, 10 sayısını nasıl string yaparsınız?

      "text".class # => String

      # Bir stringi tırnaklar içinde ifade ederek belirtebilirsiniz

      "abc" # => "abc"
      'abc' # => "abc"
    %br
    
    %br
    %h4.sag 11-stdin-and-stdout.rb
    :coderay
      #!Ruby
      # Klasik programlar bir terminalde çalışır yazı girişlerini okur ve çıktı olarak yazı geri verirler.
      # Bu birçok farklı programın birbiriyle etkileşimde bulunduğu ortak bir arabirimdir.

      # Bir program yazı çıktısı verdiğinde biz onu standart çıkışa (stdout) gönderdiğini kabul ederiz.
      # Terminalde stdout'a gönderilen her çıktı terminalde gösterilir.
      # Örneğin cat komutu dosya içeriğini standart çıkışa gönderir, echo argümanlarını standart çıkışa gönderir.

      # Progam ne zaman bir yazı okursa onu standart girişten alır (stdin).
      # Terminalde stdin tuş takımınızdan gelen bilgileri alır.
      # Klavyeden ne girerseniz programınızın stdin'ine gönderilir.

      # stdin'den bir giriş okumak için gets komutu kullanılır
      user_response = gets

      # stdout'a yazmak için puts komutu kullanılır
      puts "Dediniz ki: \#{user_response}"



      # Dikkat
      #
      # Bir satır enter tuşuyla biten bir yazıdır. line = "Line\n"
      # Satırı okuduğunuzda ayrıca enter tuşunu da okursunuz.
      # Bunun anlamı: line + line # => "Line\nLine\n"
      #
      # Eğer _gerçekte_ "LineLine" istiyorsanız:
      # enter tuş karakterini uzaklaştırmanız gerekir.
      #
      # Ruby size chomp adı verilen ve dizin,n sonundan enter tuş karakterini çıkaran bir metod verir
      # line.chomp # => "Line"
      # line # => "Line\n"
      #
    %br
    
    %br
    %h4.sag 12-puts.rb
    :coderay
      #!Ruby
      # Ruby yazıları stdout'a göndermek için birçok metoda sahiptir, en çok kullanılanı puts'dir:
      puts "Welcome to the program!"
      
        # Çıktı:
        # Welcome to the program!
        #


      # Dikkat ederseniz puts yazdığı yazınını arkasına yeni satıra geçiş ekler ve puts yazacağı nesneyi önce 
      # string'e çevirir , sonra yazar:
      puts 45
      
        # Çıktı:
        # 45
        #
      
      
      # puts diğer nesneleri String'e çevirirken onların to_s metodunu kullanır.
      # ve sonra string değeri yazar. Şöyle çalışır.
      number = 56
      thing_to_print = number.to_s
      puts thing_to_print

        # çıktı:
        # 56
        #
    %br
    
    %br
    %h4.sag 13-single-vs-double-quotes.rb
    :coderay
      #!Ruby
      # Ruby'de stringleri ifade etmek için iki yol vardır: çift tırnaklarla (" ") ya da tek tırnaklarla (' ')
      # Çift tırnaklarla enter tuşu karakteri (\n) gibi string yazılırken dönüştürülecek özel karakterleri de ifade edebilirsiniz
      # Tek tırnaklarla string aynen ifade edildiği gibi çıkışa yazdırılır
      
      puts "Bura'da\nİki satır var."
      puts 'Bu sadece\nbir satır çıktı verir'
      
        # Çıktı:
        # Bura'da
        # İki satır var.
        # Bu sadece\nbir satır çıktı verir
    %br
    
    %br
    %h4.sag 14-operators-on-strings.rb
    :coderay
      #!Ruby
      # Basit operatörleri tıpkı diğer nesnelerdeki gibi String'e de kullanabilirsiniz:
      
      my_string = "Face"
      your_string = "book"
      
      my_string + your_string # => "Facebook"
      
      my_string == your_string # => false
      my_string = "book"
      my_string == your_string # => true
    %br
    
    %br
    %h4.sag 15-interpolation.rb
    :coderay
      #!Ruby
      # Çift tırnaklar çok daha güçlüdür. Özel karakter sıralamaları kullanarak stringinizin içinde kod çalıştırabilirsiniz.
      # Bu kod çalıştırılır ve sonucu string içine eklenir.

      small_number = 5
      neg_number = -97

      puts "1 + 3 eşittir \#{1 + 3}"
      puts "Benim iki tane sayım \#{small_number} ve \#{neg_number.abs} (burada hepsi pozitif olur)"

        # Çıktı:
        # 1 + 3 eşittir 4
        # Benim iki tane sayım 5 ve 97 (burada hepsi pozitif olur)
        #

      # Dikkat ettiyseniz \#{} içine herşeyi koyabiliriz , nesnelere referans verebileceğimiz gibi metod da çalıştırabiliriz.
    %br
    
    %br
    %h4.sag 16-p.rb
    :coderay
      #!Ruby
      # Bir diğer önemli çıkış metodu da 'p' metodudur. p bir nesnenin dahili tanımını çıkışa yazar:
      # bunu nesnenin kod içinde nasıl göründüğü olarak düşünebilirsiniz. Bu çeşit çıktı bizim kod yazarken
      # sağ tarafta yazdıklarımıza benzer.
      
      puts "Rain and lightning"
      p "Rain and lightning"
      
        # puts çıktısı:
        # Rain and lightning
        
        # p çıktısı:
        # "Rain and lightning"
        
        
      # Dikkat ettiyseniz p metodu string kenarlarına çift tırnak koydu. Bir örnek daha verelim.
      # (Ruby'de nesnelerden oluşan bir listeye Array denir. Array üzerinde daha sonra duracağız)
      
      array = [1, 2, 3]
      
      puts array
      p array
      
      # Çıktı:
      
        # puts:
        # 1
        # 2
        # 3
        
        # p:
        # [1, 2, 3]
    %br
    
    %br
    %h4.sag 17-naming-conventions.rb
    :coderay
      #!Ruby
      # Şimdiye kadar baktığımız tüm değişkenler yerel değişkenlerdi.
      # Bunun anlamı onlar bulunulan ortamda geçerliler , fakat ortamı terkedersek yok olurlar.
      # Yerel değişkenler küçük harfle başlarlar ve alfanumerik değerler ya da alt çizgilerle devam edebilir.
      # Ruby'de stil olarak değişken isimlerinde snake_case denilen kelimeleri alt çizgiyle birleştirme tercih edilir
      local_variable = nil
      
      # Sabitler de değişkenlere benzer fakat bunların değerleri değişmeyecektir.
      # Büyük harfle başlayan değişken isimleri bir sabiti gösterir.
      # Ruby'de stil olarak sabit isimlerinde CamelCase denilen kelimeleri ilk harfleri büyüterek birleştirme tercih edilir.
      SabitDeger = nil
      
      
      # Oluşum değişkenleri (instance variables) bulunulan ortama değil nesneye aittirler.
      # '@' işaretiyle başlayan değişken isimleri oluşum değişkenlerini gösterir.
      # Bu konuda daha sonra ayrıntılı konuşacağız.
      @instance_variable = nil
      
      
      # Hatırlarsanız size metodların kendi küçük dünyaları olduğunu söylemiştim. Biraz yalandı.
      # Sabitler kendi scope'larındaki (ortamlarındaki) her yerden görülebilirler.
      
      MyConstant  = 12
      my_variable = 13
      def example
        begin
          MyConstant        # => 12
          my_variable       # => 
        rescue => exception
          exception         # => #<NameError: undefined local variable or method `my_variable' for main:Object>
        end
      end
      
      example       # metodu çağırır
      
      
      # soru: Sınıf isimleri büyük harfle başlar, bunlar bir sabit midir?
      #   Unutmayın, sabitler değişmemeleri beklenen değişkenlerdir.
      #   bunu irb'le test edin
      
      
    %br
    
    %br
    %h4.sag 18-keywords.rb
    :coderay
      #!Ruby
      # keyword'lara dikkat etmeliyiz, çünkü bunlar Ruby'de başka anlamlar ifade eden kelimelerdir.
      # Bunun anlamı onları değişken ismi olarak kullanamayız.
      #
      # Eğer birini kullanırsanız yorumlayıcı sizi hemen haberdar edecektir.
      # Eğer Ruby bilen bir editörde program yazıyorsanız, editörün renklendirdiği yazıları kullanmayın :)
      # 
      # Eğer tam_bir_liste istiyorsanız, http://www.google.com/search?&q=ruby+keywords+list
      
      
      
      
      # def metod tanımlamak için bir keyword. Özel bir anlamı var , değişken adında kullanamazsınız.
      
      def = 3 # !> useless use of a literal in void context
      # ~> -:14: syntax error, unexpected '='
      # ~> def = 3 # !> useless use of a literal in void context
      # ~>      ^
    %br
    
    %br
    %h4.sag 19-nil.rb
    :coderay
      #!Ruby
      # nil adında özel bir nesne vardır
      nil.class # => NilClass
      
      # Bir nesne gösteremediğinizde bunu ifade etmek için bu nesneyi kullanırsınız.
      array = [1,5,7]
      array.find { |number| number * 2 == 10 } # => 5
      array.find { |number| number * 2 == 11 } # => nil
    %br
    
    %br
    %h4.sag 20-logic.rb
    :coderay
      #!Ruby
      # Hayatınız boyunca, koşullara göre bişey yapmanız gerekince lojik (mantık) kullanırsınız.
      # Lojik iki değere sahiptir: true ve false (doğru ve yanlış)
      # Şöyle konuşursunuz : "eğer yağmur varsa ve şemsiyem varsa dışarı çıkarım, yoksa içerde kalırım."
      # Bu bir lojik yapıdır.
      # 
      # Ruby'de de böyle mantıksal yapılar vardır, bu sayede dışarı çıkabilirliğinizi test eden program yazılabilir, hadi yapalım!
      
      def go_outside?(raining, umbrella)
        raining && umbrella
      end
      
      go_outside?( true  , true  )  # => true
      go_outside?( true  , false )  # => false
      go_outside?( false , true  )  # => false
      go_outside?( false , false )  # => false
      
      # bakın, go_outside? metodu gerçekten ne yapacağını biliyor, çünkü lojik biliyor!
    %br
    
    %br
    %h4.sag 21-true-and-false.rb
    :coderay
      #!Ruby
      # Ruvy'deki lojik "boolean" nesnelerle yapılır. Yanlış bilmiyorsam bu lojiği geliştiren kişinin adından geliyor!
      # Bir boolean nesne değeri 'doğru' ya da 'yanlış' (true-false) olabilecek nesnedir.
      
      # true nesnesi:
      true.class                      # => TrueClass
      'yep, its true'   if true       # => "yep, its true"
      
      # false nesnesi:
      false.class                     # => FalseClass
      'nope, its not true' if false   # => nil
      
      # önlerine ünlem işareti koyarak birbirine dönüştürebilirsiniz
      !true     # => false
      !false    # => true
      !!true    # => true
      !!false   # => false
      
      
      # Fakat diğer tüm nesneler ne olacak? Onlar da boolean olmak istiyor!
      # Aşağıdaki gibi dönüştürülebilir! (nil hariç hepsi true sonuç verir)
      
      [0, 1, "two", :three, Object.new, nil].each do |object|
        !!object # => true, true, true, true, true, false
      end
    %br
    
    %br
    %h4.sag 22-if-else.rb
    :coderay
      #!Ruby
      # Diyelim bazı şeyleri koşula bağlı yapmak istiyorsunuz
      
      if 4 == (2 + 2)             # eğer 4 ve (2+2) değerleri eşitse
        "Burdaki işlem yapılır"   # => "Burdaki işlem yapılır"
      else
        "Bu yapılmaz :("        # => 
      end
      
      
      my_number = 56
      
      if my_number < 12
        puts "Bir düzineden az"
      elsif my_number < 64
        puts "6 sayıya kadar beni yakalayacaksın"
      else
        puts "Bu gerçekten büyük bir sayı"
      end
      
        # Çıktı:
        # 6 sayıya kadar beni yakalayacaksın
        # 
      
      
      'tek satırda if komutu'     if true       # => "tek satırda if komutu"
      'tek satırda unless komutu' unless false  # => "tek satırda unless komutu"
    %br
    
    %br
    %h4.sag 23-if-returns-a-value.rb
    :coderay
      #!Ruby
      # Ruby'de kod yazdığınız her yer bir değer geri döner buna 'if' yapısı da dahildir
      
      sonuc = if true
        "evet, doğru"
      else 
        "hayır, yanlış"
      end
      
      result # => "evet, doğru"
      
      
      # bunu metod içinde yapalım
      def if_deger_doner(bool)
        if bool
          "evet, doğru"
        else
          "hayır, yanlış"
        end
      end
      
      if_deger_doner true     # => "evet, doğru"
      if_deger_doner false    # => "hayır, yanlış"
      
      
      
      # benzer şekilde unless
      def unless_deger_doner(bool)
        unless bool
          "hayır, yanlış"
        else
          "evet, doğru"
        end
      end
      
      unless_deger_doner true   # => "evet, doğru"
      unless_deger_doner false  # => "hayır, yanlış"
    %br
    
    %br
    %h4.sag 24-go-do-the-challenges.rb
    :coderay
      #!Ruby
      # Tamam, hepsini bir geçtik :)
      # Şimdi düellolara gitmeniz gerekiyor (challenges)
      # 
      # Editörünüzde düelloları açın ve ilkini tamamlamaya çalışın.
      # Sonra terminalde Rakefile olan klasöre gidin ve "rake 1:1" komutu çalıştırın.
      # 
      # Geçtiniz mi? Hayır?
      # Tamam , çıktıyı okuyun ve tekrar deneyin. Neyin yanlış olduğunu söylüyor?
      # Bir daha deneyin!
      # 
      # Geçtiniz mi? Evet?
      # Harika! Geri kalanları da bitirin :D



      # !!!!!!!!!!UNUTMAYIN!!!!!!!!!
      # Size yardımcı olmak için cheatsheet'ler (referans sayfaları) var. Onlardan destek alabilirsiniz!
      #
      # Nasıl kullanılacak bu cheatsheet'ler?
      # Onları bir okuyun ve içlerinde ne olduğuna bir göz atın.
      # Sonra birşeyi kullanmaya ihtiyaç duyduğunuzda önce nasıl bişey olduğunu hatırlayın.
      # Eğer hatırlayamazsanız gidip buralardan tekrar bakın.
      # Çözüm konusunda bir yönteme odaklanın ve hemen onu arayıp bulun.
      # Bu sayede kullanmak istediğiniz şeyi daha çabuk öğrenirsiniz.
      # 
      # Oturup tüm sayfayı hatırlamanıza gerek yok (yapabiliyorsanız ne ala)
      # Önemli olan o sayfada temel olarak nelerin olduğunu hatırlamak ve 
      # sık kullandığınız parçaları hatırlamak
      #

      # Bu bölüm için şunlara ihtiyacınız var:
      # https://github.com/JoshCheek/ruby-kickstart/blob/master/cheatsheets/logic_and_control.rb
      # https://github.com/JoshCheek/ruby-kickstart/blob/master/cheatsheets/strings.rb
    
    
%hr

#disqus_thread
%script(type="text/javascript" async="true" src="http://ruby-tr.disqus.com/embed.js")
  
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
